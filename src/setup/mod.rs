use std::{
    collections::HashMap,
    fs::{create_dir_all, write},
    path::{Path, PathBuf},
    process::{Command, Stdio},
};

use anyhow::{Context, Result, bail};
use which::which;

use crate::{
    cache::FabricateCache,
    setup::{lua::lua_eval_config, ninja::build_ninja_file},
};

mod lua;
mod ninja;

pub fn setup(config_file: String, build_dir: String, prefix: String, options: Vec<(String, String)>, dependency_overrides: Vec<(String, String)>) -> Result<()> {
    let ninja_path = match which("ninja") {
        Err(err) => {
            println!("Warning: failed to locate ninja, cannot cleanup or generate compdb ({})", err);
            None
        }
        Ok(path) => Some(path),
    };

    // Resolve config
    let mut config_file = Path::new(&config_file).canonicalize().context("Failed to resolve config path")?;
    let config_dir: PathBuf;
    if config_file.is_dir() {
        config_dir = config_file;
        config_file = config_dir.join("fab.lua")
    } else {
        config_dir = match config_file.parent() {
            None => bail!("Failed to resolve config directory"),
            Some(config_dir) => config_dir.to_path_buf(),
        };
    }

    // Create build dir
    let mut build_dir = PathBuf::from(build_dir);
    if build_dir.is_relative() {
        build_dir = config_dir.join("build");
    }
    create_dir_all(&build_dir).context("Failed to create build directory")?;

    // Write gitignore
    write(build_dir.join(".gitignore"), "# Generated by Fabricate\n*").context("Failed to write .gitignore")?;

    // Load cache
    let cache_path = build_dir.join("fabricate_cache.toml");
    let cache = FabricateCache::load(&cache_path)?;

    // Cleanup build directory
    if let Some(ninja_path) = &ninja_path {
        if cache.is_some() {
            let mut cleanup_cmd = Command::new(ninja_path);
            if let Err(err) = cleanup_cmd.arg("-C").arg(&build_dir).arg("-t").arg("cleandead").status() {
                println!("Warning: ninja cleanup failed ({})", err);
            }
        }
    }

    // Evaluate lua config
    let (rules, builds, git_deps, installs) = match lua_eval_config(
        config_dir.to_path_buf(),
        build_dir.to_path_buf(),
        config_file,
        HashMap::from_iter(options.clone()),
        cache,
        HashMap::from_iter(dependency_overrides.clone()),
    ) {
        Err(err) => bail!("{}", err),
        Ok(config) => config,
    };

    // Update cache
    let cache = FabricateCache::new(&cache_path, prefix, HashMap::from_iter(options), installs, git_deps);

    cache.update()?;

    // Build ninja file
    write(build_dir.join("build.ninja"), build_ninja_file(&rules, &builds)).context("Failed to write ninja build file")?;

    // Build compdb
    if let Some(ninja_path) = ninja_path {
        let mut compdb_rules = Vec::new();
        for rule in rules {
            if !rule.build_compdb {
                continue;
            }

            compdb_rules.push(rule.name.clone());
        }

        if compdb_rules.len() > 0 {
            let mut compdb_cmd = Command::new(ninja_path);
            let output = match compdb_cmd.arg("-C").arg(&build_dir).arg("-t").arg("compdb").stdout(Stdio::piped()).output() {
                Err(err) => {
                    println!("Warning: ninja compdb failed ({})", err);
                    return Ok(());
                }
                Ok(output) => output,
            };

            write(build_dir.join("compile_commands.json"), output.stdout).context("Failed to write compile_commands.json")?;
        }
    }

    Ok(())
}
